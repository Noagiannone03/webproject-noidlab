<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Editeur de Points & Courbe Three.js</title>
  <style>
    /* Styles de base */
    body, html {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
      overflow: hidden;
      height: 100%;
    }
    /* Le canevas d'édition occupe la moitié gauche de l'écran */
    #editorCanvas {
      position: absolute;
      left: 0;
      top: 0;
      width: 50%;
      height: 100%;
      border-right: 1px solid #ccc;
    }
    /* Le canevas Three.js occupe la moitié droite */
    #threeCanvas {
      position: absolute;
      right: 0;
      top: 0;
      width: 50%;
      height: 100%;
      background: #eee;
    }
    /* Zone de contrôle (boutons, code généré) */
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      z-index: 10;
    }
    #pointsOutput {
      margin-top: 10px;
      max-height: 200px;
      overflow-y: auto;
      white-space: pre;
      font-family: monospace;
      background: #f5f5f5;
      padding: 10px;
      border: 1px solid #ddd;
    }
    button {
      margin: 5px 5px 5px 0;
    }
  </style>
</head>
<body>
  <!-- Contrôles pour effacer et générer le code -->
  <div id="controls">
    <button id="clearButton">Effacer les points</button>
    <button id="generateButton">Générer le code</button>
    <div id="pointsOutput"></div>
    <p>Cliquez sur le canevas de gauche pour ajouter des points.</p>
  </div>

  <!-- Canevas pour dessiner les points (éditeur) -->
  <canvas id="editorCanvas"></canvas>
  <!-- Canevas pour Three.js (affichage de la courbe) -->
  <canvas id="threeCanvas"></canvas>

  <!-- Inclusion de Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    /***********************
     * Partie Éditeur de Points
     ***********************/
    // Tableau pour stocker les points (les coordonnées sont en pixels)
    const points = [];

    const editorCanvas = document.getElementById('editorCanvas');
    const ctx = editorCanvas.getContext('2d');

    // Redimensionnement du canevas d'édition
    function resizeEditorCanvas() {
      editorCanvas.width = editorCanvas.clientWidth;
      editorCanvas.height = editorCanvas.clientHeight;
      drawAllPoints();
    }
    window.addEventListener('resize', resizeEditorCanvas);
    resizeEditorCanvas();

    // Dessiner un point (petit cercle)
    function drawPoint(x, y) {
      ctx.beginPath();
      ctx.arc(x, y, 5, 0, Math.PI * 2);
      ctx.fillStyle = "red";
      ctx.fill();
    }

    // Redessiner tous les points enregistrés
    function drawAllPoints() {
      ctx.clearRect(0, 0, editorCanvas.width, editorCanvas.height);
      for (let pt of points) {
        drawPoint(pt.x, pt.y);
      }
    }

    // Ajouter un point lors d'un clic
    editorCanvas.addEventListener('click', (event) => {
      const rect = editorCanvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      // z = 0 par défaut
      points.push({ x, y, z: 0 });
      drawAllPoints();
    });

    // Bouton pour effacer les points
    document.getElementById('clearButton').addEventListener('click', () => {
      points.length = 0;
      drawAllPoints();
      document.getElementById('pointsOutput').textContent = "";
    });

    // Bouton pour générer le code Three.js
    document.getElementById('generateButton').addEventListener('click', () => {
      if (points.length === 0) {
        alert("Aucun point n'a été défini.");
        return;
      }
      // Calculer le centre (moyenne) des points pour recentrer la courbe
      let center = { x: 0, y: 0, z: 0 };
      for (let pt of points) {
        center.x += pt.x;
        center.y += pt.y;
        center.z += pt.z;
      }
      center.x /= points.length;
      center.y /= points.length;
      center.z /= points.length;

      // Facteur d'échelle pour réduire les valeurs (adaptable)
      const scaleFactor = 0.01;

      let code = "const curve = new THREE.CatmullRomCurve3([\n";
      // Appliquer le recentrage et l'échelle
      const transformedPoints = points.map(pt => 
        new THREE.Vector3(
          (pt.x - center.x) * scaleFactor,
          (pt.y - center.y) * scaleFactor,
          pt.z
        )
      );
      transformedPoints.forEach(pt => {
        code += `  new THREE.Vector3(${pt.x.toFixed(2)}, ${pt.y.toFixed(2)}, ${pt.z.toFixed(2)}),\n`;
      });
      code += "]);";
      document.getElementById('pointsOutput').textContent = code;
      console.log(code);

      // Mettre à jour la courbe Three.js avec ces points
      updateCurve(transformedPoints);
    });

    /***********************
     * Partie Three.js
     ***********************/
    const threeCanvas = document.getElementById('threeCanvas');
    const renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, antialias: true, alpha: true });
    renderer.setSize(threeCanvas.clientWidth, threeCanvas.clientHeight);
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);

    const camera = new THREE.PerspectiveCamera(50, threeCanvas.clientWidth / threeCanvas.clientHeight, 0.1, 1000);
    camera.position.set(0, 0, 5);

    // Paramètres par défaut pour le tube
    const tubularSegments = 100;
    const radius = 0.1;
    const radialSegments = 8;
    const closed = false;

    // Créer une courbe par défaut
    let curve = new THREE.CatmullRomCurve3([
      new THREE.Vector3(0, 0, 0),
      new THREE.Vector3(1, 1, 0)
    ]);
    let tubeGeometry = new THREE.TubeGeometry(curve, tubularSegments, radius, radialSegments, closed);

    // Fonction pour mettre à jour le dégradé sur le tube
    function updateTubeGradient(geometry) {
      const colors = [];
      const pos = geometry.attributes.position;
      const count = pos.count;
      for (let i = 0; i < count; i++) {
        const t = i / (count - 1);
        const c = 0.8 * t; // Le dégradé va de 0 (noir) à 0.8 (gris foncé)
        colors.push(c, c, c);
      }
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    }
    updateTubeGradient(tubeGeometry);

    const tubeMaterial = new THREE.MeshPhysicalMaterial({
      vertexColors: true,
      metalness: 0.1,
      roughness: 0.5,
      clearcoat: 0.2,
      clearcoatRoughness: 0.1,
      flatShading: true
    });

    let tubeMesh = new THREE.Mesh(tubeGeometry, tubeMaterial);
    scene.add(tubeMesh);

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();

    // Mise à jour du renderer lors du redimensionnement
    window.addEventListener('resize', () => {
      renderer.setSize(threeCanvas.clientWidth, threeCanvas.clientHeight);
      camera.aspect = threeCanvas.clientWidth / threeCanvas.clientHeight;
      camera.updateProjectionMatrix();
    });

    // Fonction pour mettre à jour la courbe et le tube avec les nouveaux points transformés
    function updateCurve(transformedPoints) {
      // Créer une nouvelle courbe à partir des points transformés
      curve = new THREE.CatmullRomCurve3(transformedPoints);
      // Libérer l'ancienne géométrie
      tubeGeometry.dispose();
      // Créer une nouvelle géométrie pour le tube
      tubeGeometry = new THREE.TubeGeometry(curve, tubularSegments, radius, radialSegments, closed);
      updateTubeGradient(tubeGeometry);
      tubeMesh.geometry = tubeGeometry;
    }
  </script>
</body>
</html>
